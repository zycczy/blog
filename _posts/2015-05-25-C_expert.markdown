---
layout:     post
title:      "《Expert C Programming》之 segments"
date:       2015-05-25 12:25:00
author:     "程照原"
header-img: "img/home-bg.jpg"
---
#《Expert C Programming》之 segments
　　在linux编程中很容易出现一种错误叫做“segments fault”，也就是常见的段错误，昨天在看《Expert C Programming》的时候，在书中的第6章很细致的讲了“segments”的细节，所以今天专门写一篇blog记录一下。

　　首先先要了解一下Object file(对象文件)的三个种类：

    (1)Relocatable file 可重定位文件:
    　　一般为以.o结尾的由汇编器(如GAS)汇编生成的文件，之后link editor拿一个或多个Relocatable Object file做为输入，经链接处理之后，生成一个Executeable file或者一个Shared object file。当然也可以用ar工具来将众多的Relocatable file生成.a静态链接库。在内核中加载的.ko模块也是Relocatable file。
    (2)Executable file 可执行文件
    　　在linux系统里有两种可执行的文件，除了这里说的Executable object file还有另外一种就是可执行的脚本，他们都是文本文件需要相应的解释器来将他们执行。
    (3)Shared object file 可被共享的对象文件
    　　这就是常说到的动态链接库，.so文件。如果拿前面的静态库来生成可执行程序，那每个程序都会有一份库代码的拷贝。如果在磁盘中存储这些可执行程序，那就会占用额外的磁盘空间，如果放入Linux系统上一起运行，也会浪费掉物理内存。如果将静态库换成动态库，那么这些问题都不会出现。动态库在发挥作用的过程当中，必须经过如下两个步骤：
    　　a)link editor(链接编辑器)拿它和其他Relocatable object file以及其他的Shared object file作为输入，经链接处理后，生成另外的shared object file或者executable file。
    　　b)在运行时，dynamic linker(动态链接器)拿它和一个Executable file以及另外一些Shared objet file来一起处理，在linux系统里面创建一个进程映像。

　　在下面这张图片中就可以看出三个不同种类的文件了，而且也可以看出x86是LSB(小端)的32位结构。
![file](/blog/img/file_property.jpg)
　　当在一个可执行文件中运行size指令时，他会告诉你这个文件中的三个segments(text，data，bss)的大小。
![file](/blog/img/size.jpg)
　　C语言的各个部分会出现在以下这些段中，需要提到的是局部变量不进入段中，他们在运行时才被创建。
     
     ————————————————————————————————
     |magic number			|
     ————————————————————————————————
     |其他内容			|
     ————————————————————————————————
     |BSS段所需大小			|
     ————————————————————————————————
     |数据段				| 
     |   初始化后的全局变量和静态变量	|
     ————————————————————————————————
     |文本段				|
     |   可执行文件的指令		|
     ————————————————————————————————

　　由于BSS段之保存没有值的变量，所以事实上他并不需要保存着这些变量的映像。运行时所需要的的BSS段的大小记录在目标文件中，但BSS段本身(不像其他段)并不占据目标文件的任何空间。

　　讲到elf格式的文件不得不提到的就是a.out了，虽然a.out现在已经被elf所替代，但是unix系统里面依然保留了这种文件格式，毕竟这是unix最初的东西嘛。

　　再讲回segments的问题，为什么执行文件要以短的形式组织呢？因为段可以方便地映射到链接器在运行时直接载入的对象中。

　　文本段包含程序的指令。链接器把指令直接从文件拷贝到内存中，以后便再也不用管他。因为在典型情况下，程序的文本无论是内容还是大小都不会改变。有些操作系统和链接器甚至可以向segment中不同的section赋予适当的属性(读，写，执行)。

　　数据段包含经过初始化的全局和静态变量以及它们的值。

　　BSS段的大小从可执行文件中得到，然后连接器得到这个大小的内存块，紧跟在数据段后面。当这个内存区进入程序的地址空间后全部清零，包括数据段和BSS段的整个区段此时通常成为数据区。这是因为在操作系统的内存管理术语中，segment就是一片连续的虚拟地址，所以相邻的segment呗接合。一般情况下，在任何进程中数据段是最大的段。

![file](/blog/img/share_img.jpg)

　　当考虑到共享库是，进程的地址空间的样子如上图所示
