---
layout:     post
title:      "《Expert C Programming》之 segments(2)"
date:       2015-05-29 16:11:00
author:     "程照原"
header-img: "img/home-bg.jpg"
---
#《Expert C Programming》之 segments(2)
　　接着上一篇继续说，这篇主要讲一下可执行文件的组成。

　　当在一个可执行文件中运行size指令时，他会告诉你这个文件中的三个segments(text，data，bss)的大小。
![file](/blog/img/size.jpg)
　　C语言的各个部分会出现在以下这些段中，需要提到的是局部变量不进入段中，他们在运行时才被创建。
     
     ————————————————————————————————
     |magic number			|
     ————————————————————————————————
     |其他内容			|
     ————————————————————————————————
     |BSS段所需大小			|
     ————————————————————————————————
     |数据段				| 
     |   初始化后的全局变量和静态变量	|
     ————————————————————————————————
     |文本段				|
     |   可执行文件的指令		|
     ————————————————————————————————

　　由于BSS段之保存没有值的变量，所以事实上他并不需要保存着这些变量的映像。运行时所需要的的BSS段的大小记录在目标文件中，但BSS段本身(不像其他段)并不占据目标文件的任何空间。

　　讲到elf格式的文件不得不提到的就是a.out了，虽然a.out现在已经被elf所替代，但是unix系统里面依然保留了这种文件格式，毕竟这是unix最初的东西嘛。

　　再讲回segments的问题，为什么执行文件要以短的形式组织呢？因为段可以方便地映射到链接器在运行时直接载入的对象中。

　　文本段包含程序的指令。链接器把指令直接从文件拷贝到内存中，以后便再也不用管他。因为在典型情况下，程序的文本无论是内容还是大小都不会改变。有些操作系统和链接器甚至可以向segment中不同的section赋予适当的属性(读，写，执行)。

　　数据段包含经过初始化的全局和静态变量以及它们的值。

　　BSS段的大小从可执行文件中得到，然后连接器得到这个大小的内存块，紧跟在数据段后面。当这个内存区进入程序的地址空间后全部清零，包括数据段和BSS段的整个区段此时通常成为数据区。这是因为在操作系统的内存管理术语中，segment就是一片连续的虚拟地址，所以相邻的segment呗接合。一般情况下，在任何进程中数据段是最大的段。

![file](/blog/img/share_img.jpg)

　　当考虑到共享库是，进程的地址空间的样子如上图所示
